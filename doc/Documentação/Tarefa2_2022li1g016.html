<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Tarefa2_2022li1g016</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Daniel Silva &lt;a104086@alunos.uminho.pt&gt;<br />H&#233;lder Gomes &lt;a104100@alunos.uminho.pt&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">Tarefa2_2022li1g016</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>M&#243;dulo para a realiza&#231;&#227;o da Tarefa 2 do projeto de LI1 em 2022/23.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:estendeMapa">estendeMapa</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Int -&gt; <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a></li><li class="src short"><a href="#v:vRio">vRio</a> :: <a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a> -&gt; Int -&gt; <a href="LI12223.html#t:Velocidade" title="LI12223">Velocidade</a></li><li class="src short"><a href="#v:estendeTerreno">estendeTerreno</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Int -&gt; <a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a></li><li class="src short"><a href="#v:estendeObstaculo">estendeObstaculo</a> :: Int -&gt; (<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]) -&gt; StdGen -&gt; Int -&gt; Int -&gt; Int -&gt; [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]</li><li class="src short"><a href="#v:proximosTerrenosValidos">proximosTerrenosValidos</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; [<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>]</li><li class="src short"><a href="#v:proximosObstaculosValidos">proximosObstaculosValidos</a> :: Int -&gt; (<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]) -&gt; [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:estendeMapa" class="def">estendeMapa</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Int -&gt; <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> <a href="#v:estendeMapa" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o recebe um Mapa v&#225;lido e um inteiro (n&#250;mero de 0 a 100) e retorna o mesmo mapa estendido.
O n&#250;mero de 0 a 100 &#233; utilizado nesta fun&#231;&#227;o e em v&#225;rias outras para criar uma pseudo-aleatoriedade &#224; estens&#227;o do mapa.
Esta fun&#231;&#227;o utiliza v&#225;rias fun&#231;&#245;es auxiliares defenidas abaixo. </p><pre>estendeMapa :: Mapa -&gt; Int -&gt; Mapa
estendeMapa (Mapa largura ((terr, obst):t)) n | terreno == Rio 0 = (Mapa largura ((Rio (vRio terr n), obstaculos):(terr, obst):t))
                                              | terreno == Estrada 0 = (Mapa largura ((Estrada vEstrada, obstaculos):(terr, obst):t))
                                              | terreno == Relva = (Mapa largura ((Relva, obstaculos):(terr, obst):t))
    where
        terreno = estendeTerreno (Mapa largura ((terr, obst):t)) n
        obstaculos = estendeObstaculo largura (terreno, []) (mkStdGen n) 0
        vEstrada = if n &gt; 50 then (mod n 3) +1 else -(mod n 3) -1
</pre><h2>Exemplos de utiliza&#231;&#227;o:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>estendeMapa (Mapa 3 [(Rio (-1), [Nenhum, Tronco, Tronco])]) 13 = Mapa 3 [(Estrada (-2), [Carro, Carro, Nenhum]), (Rio (-1), [Nenhum, Tronco, Tronco])]
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:vRio" class="def">vRio</a> :: <a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a> -&gt; Int -&gt; <a href="LI12223.html#t:Velocidade" title="LI12223">Velocidade</a> <a href="#v:vRio" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o auxiliar que determina a velocidade do rio, de forma pseudo-aleat&#243;ria, entre (-4) e 4, exceto o 0.
Caso a linha anterior seja tamb&#233;m um rio, a velocidade obrigatoriamente ser&#225; de sinal contr&#225;rio.</p><pre>vRio :: Terreno -&gt; Int -&gt; Velocidade
vRio (Rio velocidade) n = if velocidade &lt; 0 then (mod n 4) +1 else -(mod n 4) -1
vRio _ n = if n &gt; 50 then (mod n 3) +1 else -(mod n 3) -1
</pre></div></div><div class="top"><p class="src"><a id="v:estendeTerreno" class="def">estendeTerreno</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Int -&gt; <a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a> <a href="#v:estendeTerreno" class="selflink">#</a></p><div class="doc"><p>Esta fun&#231;&#227;o recebe um Mapa e atrav&#233;s de uma lista de poss&#237;veis terrenos, escolhe de forma pseudo-aleat&#243;ria o pr&#243;ximo terreno.  </p><pre>estendeTerreno :: Mapa -&gt; Int -&gt; Terreno
estendeTerreno mapa@(Mapa largura ((terreno, obstaculos):t)) n = terreno !! mod n (length terreno)
        where terreno = proximosTerrenosValidos mapa
</pre><h2>Exemplos de utiliza&#231;&#227;o:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>estendeTerreno (Mapa 3 [(Rio (-1), [Nenhum, Tronco, Tronco])]) 31 = Estrada 0
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:estendeObstaculo" class="def">estendeObstaculo</a> <a href="#v:estendeObstaculo" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Int</td><td class="doc"><p>largura</p></td></tr><tr><td class="src">-&gt; (<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])</td><td class="doc"><p>tuplo de terreno com lista vazia de obst&#225;culos</p></td></tr><tr><td class="src">-&gt; StdGen</td><td class="doc"><p>n&#250;mero pseudo-aleat&#243;rio</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>acumulador para contagem de n&#250;mero de obst&#225;culos</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>acumulador para contagem de carros</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>acumulador para contagem de troncos</p></td></tr><tr><td class="src">-&gt; [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]</td><td class="doc"><p>lista de obst&#225;culos pseudo-aleat&#243;rio</p></td></tr></table></div><div class="doc"><p>A fun&#231;&#227;o de forma recursiva e atrav&#233;s de uma lista de obst&#225;culos v&#225;lida, gera uma lista de obst&#225;culos pseudo-aleat&#243;ria.
Quando o tamanho da lista de obst&#225;culos for igual &#224; largura, a fun&#231;&#227;o para.</p><pre>estendeObstaculo :: Int -&gt; (Terreno, [Obstaculo]) -&gt; StdGen -&gt; Int -&gt; Int -&gt; Int -&gt; [Obstaculo]
estendeObstaculo largura (terreno, obstaculos) gen acc nCarros nTroncos
        | largura &lt;= acc = []
        | acc == 0 = Nenhum : estendeObstaculo largura (terreno, obstaculos) nextGen (acc +1) 0 0
        | terreno == Relva = obstaculo : estendeObstaculo largura (terreno, obstaculos) nextGen (acc +1) 0 0
        | (obstaculo == Carro) &amp;&amp; (nCarros &lt; 3) = obstaculo : estendeObstaculo largura (terreno, obstaculos) nextGen (acc +1) (nCarros +1) nTroncos
        | (obstaculo == Tronco) &amp;&amp; (nTroncos &lt; 5) = obstaculo : estendeObstaculo largura (terreno, obstaculos) nextGen (acc +1) nCarros (nTroncos +1)
        | otherwise = Nenhum : estendeObstaculo largura (terreno, obstaculos) nextGen (acc +1) 0 0
        where obstaculo = obstValidos !! mod n (length obstValidos)
                where obstValidos = proximosObstaculosValidos largura (terreno, obstaculos)
              (n, nextGen) = next gen
</pre></div></div><div class="top"><p class="src"><a id="v:proximosTerrenosValidos" class="def">proximosTerrenosValidos</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; [<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>] <a href="#v:proximosTerrenosValidos" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o que recebe uma mapa e atrav&#233;s de Patter Matching devolve uma lista com os pr&#243;ximos terreno v&#225;lidos.  </p><pre>proximosTerrenosValidos :: Mapa -&gt; [Terreno]
proximosTerrenosValidos (Mapa _ []) = [Rio 0, Estrada 0, Relva]
proximosTerrenosValidos (Mapa _ ((Rio _, _):(Rio _, _):(Rio _, _):(Rio _, _):_)) = [Estrada 0, Relva]
proximosTerrenosValidos (Mapa _ ((Estrada _, _):(Estrada _, _):(Estrada _, _):(Estrada _, _):(Estrada _, _):_)) = [Rio 0, Relva]
proximosTerrenosValidos (Mapa _ ((Relva, _):(Relva, _):(Relva, _):(Relva, _):(Relva, _):_)) = [Estrada 0, Rio 0]
proximosTerrenosValidos (Mapa _ _) = [Rio 0, Estrada 0, Relva]
</pre><h2>Exemplos de utiliza&#231;&#227;o:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>proximosTerrenosValidos (Mapa 3 [(Rio (-1), [Nenhum, Tronco, Tronco])]) = [Rio 0,Estrada 0,Relva]
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:proximosObstaculosValidos" class="def">proximosObstaculosValidos</a> :: Int -&gt; (<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]) -&gt; [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>] <a href="#v:proximosObstaculosValidos" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o recebe a largura de uma mapa e um tuplo com um terreno e uma lista de obst&#225;culos e devolve uma lista de poss&#237;veis obst&#225;culos.
 - A fun&#231;&#227;o devolve: 
   .lista vazia se a lista de obst&#225;culos estiver completa.
   .lista com Nenhum, caso o n&#250;mero m&#225;ximo de obst&#225;culos seja alcan&#231;ado.
   .lista com Nenhum, caso a lista tenha apenas obst&#225;culos, para al&#233;m do Nenhum, e falte apenas 1 espa&#231;o.
   .lista com as duas op&#231;&#245;es, caso nenhuma das condi&#231;&#245;es anteriores seja atingida.</p><pre>proximosObstaculosValidos :: Int -&gt; (Terreno, [Obstaculo]) -&gt; [Obstaculo]
proximosObstaculosValidos largura (_, obstaculos) | largura == (length obstaculos) = []
proximosObstaculosValidos largura (Rio _, (Tronco: Tronco: Tronco: Tronco: Tronco: _)) = [Nenhum]
proximosObstaculosValidos largura (Estrada _, (Carro: Carro: Carro: _)) = [Nenhum]
proximosObstaculosValidos largura (terreno, obstaculos) = if ((not(elem Nenhum obstaculos)) &amp;&amp; (largura == (length obstaculos)-1)) 
                                                          then [Nenhum] 
                                                          else proximosObstaculosValidosCont largura (terreno, obstaculos) 
proximosObstaculosValidosCont :: Int -&gt; (Terreno, [Obstaculo]) -&gt; [Obstaculo]
proximosObstaculosValidosCont largura (Estrada _, _) = [Nenhum, Carro]
proximosObstaculosValidosCont largura (Rio _, _) = [Nenhum, Tronco]
proximosObstaculosValidosCont largura (Relva, _) = [Nenhum, Arvore]
</pre><h2>Exemplos de utiliza&#231;&#227;o:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>proximosObstaculosValidos 3 (Rio (-1), [Nenhum]) = [Nenhum, Tronco]
</code></strong></pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>